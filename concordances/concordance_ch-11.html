
  <!DOCTYPE html>
  <html>
  <head>
    <meta charset=utf-8>
    <meta name=viewport content=width=device-width, initial-scale=1>
    <title>Concordances</title>
    <link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css>
  </head>
      <body>
        <table class=table>
          <thead>
            <tr>
            <th class="has-text-right">Contexte gauche</th>
            <th>Cible</th>
            <th class="has-text-left">Contexte droit</th>
            </tr>
          </thead>
          <tbody>
  
<tr><td class=has-text-right>0 与</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>的</td></tr>
<tr><td class=has-text-right>2-way状态表示路由器已在</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>HELLO数据包的Neighbor字段中收到自己的路由器ID。从处</td></tr>
<tr><td class=has-text-right>init状态表示路由器收到来自</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>的HELLO数据包，但是尚未建立双向通信。Cisco 路由器</td></tr>
<tr><td class=has-text-right>MTU)不匹配或接收到意外的DBD序列号。有关详细信息，请参阅为什么 OSPF </td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left></td></tr>
<tr><td class=has-text-right>Neighbor 字段中显示所有处于 init 状态（或更高状态）</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>的</td></tr>
<tr><td class=has-text-right>OSPF区域类型在一个</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>上是stub，但同一区域中的相邻  show running-config </td></tr>
<tr><td class=has-text-right>  • OSPF是否配置为本地或</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>/邻接路由器接口的被动接口？输入 show ip ospf</td></tr>
<tr><td class=has-text-right>OSPF </td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>问题的典型原因</td></tr>
<tr><td class=has-text-right>OSPF 配置在</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>的辅助网络上，而非主网络上。这是阻止 show ip </td></tr>
<tr><td class=has-text-right> ping 和 traceroute 命令。使用OSPF</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>路由表 </td></tr>
<tr><td class=has-text-right>    Serial0/0 接口与其</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>上的 Serial0/0 接口进行连接、Serial1/</td></tr>
<tr><td class=has-text-right> show ip ospf neighbor 命令显示</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>停滞在 2-Way 状态？</td></tr>
<tr><td class=has-text-right>一旦路由器与邻居形成邻接关系，它首先交换其链路状态数据库的完整副本。</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>也是一</td></tr>
<tr><td class=has-text-right>下表列出了OSPF</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>在尝试建立邻接关系时出现问题的原因，并列出了一些可用于检验问</td></tr>
<tr><td class=has-text-right>于init状态的</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>接收数据库描述符(DBD)数据包也会导致向2-way状态的转换。在广播和</td></tr>
<tr><td class=has-text-right>使用show ip ospf neighbor命令确定OSPF</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>的状态。此命令的输出显示以下内容之一：</td></tr>
<tr><td class=has-text-right>使用相同的路由器 ID 对 OSPF </td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>进行了错误配置。    show ip ospf show </td></tr>
<tr><td class=has-text-right>在成功形成OSPF邻接关系时，OSPF邻居会达到FULL</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>状态。要检查邻接关系，请输入 </td></tr>
<tr><td class=has-text-right>处于 down 状态的</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left></td></tr>
<tr><td class=has-text-right>处于 Exstart/Exchange 状态的</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left></td></tr>
<tr><td class=has-text-right>处于exstart或exchange状态的OSPF邻居尝试交换DBD数据包。路由器与其</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>形成主要和</td></tr>
<tr><td class=has-text-right>处于 init 状态</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left></td></tr>
<tr><td class=has-text-right>处于 loading 状态的</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left></td></tr>
<tr><td class=has-text-right>处于双向状态的</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left></td></tr>
<tr><td class=has-text-right>如果通过OSPF进程删除了邻居，则通过接收HELLO数据包动态发现的</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>可以回退到down状</td></tr>
<tr><td class=has-text-right>如果邻居处于down状态，请验证该</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>路由器是否处于打开状态、是否处于活动状态以及</td></tr>
<tr><td class=has-text-right>定邻居的信息，则此路由器没有收到来自该</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>的任何“有效”OSPF HELLO。这意味着 </td></tr>
<tr><td class=has-text-right>              导致</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>邻接问题的原因                    用于诊断问题的命令</td></tr>
<tr><td class=has-text-right>建立邻接关系，而连接到广播介质（如以太网）的路由器只能与接口上的一小部分</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>路</td></tr>
<tr><td class=has-text-right>态。例如，当OSPF在比Dead计时器间隔长的一段时间内，没有收到来自</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>的HELLO数据包</td></tr>
<tr><td class=has-text-right>  • 您的接口和</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>/邻接路由器的接口上是否都启用了OSPF?输入 show ip ospf</td></tr>
<tr><td class=has-text-right>排除OSPF</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>故障</td></tr>
<tr><td class=has-text-right>接口类型在邻接关系的形成过程中起着主要作用。例如，点对点链路上的</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>始终会尝试</td></tr>
<tr><td class=has-text-right>时，此类邻居的down状态是暂时的；它们会进入更高状态或从已知</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>的表中删除。这被</td></tr>
<tr><td class=has-text-right>未接收到任何来自</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>的 HELLO 数据包，或者收到的 HELLO </td></tr>
<tr><td class=has-text-right>  • 本地路由器和</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>路由器上的接口是否为 up 并且线路协议也为 up？输入 </td></tr>
<tr><td class=has-text-right>本文档介绍开放最短路径优先(OSPF)</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>如何成为完全邻接的常见问题。</td></tr>
<tr><td class=has-text-right>样，会轮流交换整个链路状态数据库。在经过几个</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>状态后，路由器会完全邻接。</td></tr>
<tr><td class=has-text-right>      □ 检查可以禁止将IP数据包从一个邻居转发到另一个</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>的任何入站访问列表或其</td></tr>
<tr><td class=has-text-right>  • 检查</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>路由器之间的IP连接，如下所示：</td></tr>
<tr><td class=has-text-right>  • 检验</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>接口上的以下HELLO参数是否匹配：</td></tr>
<tr><td class=has-text-right>  • 检验</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>路由器是否具有不同的路由器ID。路由器 ID 用于标识 OSPF </td></tr>
<tr><td class=has-text-right>注: neighbor 命令只能针对以下网络类型的直连</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>进行配置：</td></tr>
<tr><td class=has-text-right>的几种。有关详细信息以及所有 OSPF 邻居状态的说明，请参阅 OSPF </td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>状态。</td></tr>
<tr><td class=has-text-right>示</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>停滞在 Init 状态？</td></tr>
<tr><td class=has-text-right>计时器间隔内没有收到来自邻居的HELLO数据包，则手动配置的</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>将列为down。 </td></tr>
<tr><td class=has-text-right>路状态更新。邻接关系是一种高级</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>关系形式，由路由器形成，这些路由器在协商交换</td></tr>
<tr><td class=has-text-right>路由器 ID。要与邻居建立双向通信，路由器还必须接收</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>HELLO数据包的Neighbor字段</td></tr>
<tr><td class=has-text-right>路由器是</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>这一事实不足以保证链路状态更新的交换；它们必须形成邻接关系以交换链</td></tr>
<tr><td class=has-text-right>转换的</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>可能会交换损坏的LSA。此问题通常伴有 %OSPF-4-BADLSA </td></tr>
<tr><td class=has-text-right>通常，在down状态中看到的邻居使用 neighbor 命令。手动配置的</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>始终会出现在 OSPF</td></tr>
<tr><td class=has-text-right></td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>接口之间的MTU不匹配。                           show interface <int-type></td></tr>
<tr><td class=has-text-right>      □ 邻居是否响应 ping 命令?对分配给</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>路由器上相关接口的IP地址执行ping操作</td></tr>
<tr><td class=has-text-right></td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>未配置为stub。                                  ospf interface</td></tr>
<tr><td class=has-text-right></td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>状态</td></tr>
<tr><td class=has-text-right>邻居表中。如果OSPF从未收到来自手动配置的</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>的HELLO数据包，或者如果在上一个Dead</td></tr>
<tr><td class=has-text-right>非广播多路访问(NBMA)网络中，OSPF</td><td class=has-text-centered><strong>邻居</strong></td><td class=has-text-left>2-way状态不会引起担忧。有关 2-way </td></tr>

  </tbody>
  </table>
  </body>
  </html>
  
